<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=600">
<title>WebGPU SPH</title>
<script src="dist/utils.js"></script>
</head>
<body>
<canvas height=800 width=800></canvas>
<script>
async function testPrefixSum(device, doPrefixSum, testSize) {
    const testData = [];
    for (let i = 0; i < testSize; i++) {
        testData.push(Math.floor(Math.random() * 1000));
    }
    const testBuffer = device.createBuffer({
        size: testSize * 4,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.TRANSFER_DST | GPUBufferUsage.TRANSFER_SRC,
    });
    testBuffer.setSubData(0, new Uint32Array(testData));

    const encoder = device.createCommandEncoder({});
    doPrefixSum(device, encoder, testBuffer, testSize);

    const readbackBuffer = device.createBuffer({
        size: testSize * 4,
        usage: GPUBufferUsage.TRANSFER_DST | GPUBufferUsage.MAP_READ
    });
    encoder.copyBufferToBuffer(testBuffer, 0, readbackBuffer, 0, testSize * 4);

    console.log("testing")
    device.getQueue().submit([encoder.finish()]);

    const resultData = new Uint32Array(await readbackBuffer.mapReadAsync());

    let sum = 0;
    for (let i = 0; i < testSize - 1; i++) {
        sum += testData[i];
        if (resultData[i] != sum) {
            console.log(i, "error ", testData[i], " ", resultData[i], " " , sum);
        }
    }
    console.log("test done");
}

function compileShaderModule(device, type, source) {
    return device.createShaderModule({code: Utils.compile(type, "#version 450\n" + source)});
}

const SHADER_HEADER = `
struct Particle {
    vec2 pos;
    vec2 vel;
    vec2 accel;
    vec2 force;
    float rho;
    float pressure;
    vec2 dummy;
};

struct Constants {
    uvec2 screenSize;
    uint gridSize;
    float timestep;
    float g;
    float mass;
    float epsilon;
    float metaballVolumeThreshold;
    float metaballSurfaceThreshold;
    float particleRadius;
    float celerity;
    float rho0;
    float mu;
};

layout(std140, set = 0, binding = 0) uniform Uniforms {
    Constants constants;
};

uvec2 posToGridPos(vec2 pos) {
    return ivec2(clamp(floor(pos * constants.gridSize), 0, constants.gridSize - 1));
}

uint gridPosToOffset(uvec2 pos) {
    return pos.x + constants.gridSize * pos.y;
}
`;
const PARTICLE_SIZE = 12 // sizeof Particle / sizeof float;
const N_PARTICLES_SQRT = 150;
const N_PARTICLES = N_PARTICLES_SQRT * N_PARTICLES_SQRT;
const GRID_SIZE = N_PARTICLES_SQRT * 2;
const N_GRID_CELLS = GRID_SIZE * GRID_SIZE;
const RADIUS = 3.0 / GRID_SIZE;

async function init() {
    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();
    await Utils.ready;

    const canvas = document.querySelector('canvas');
    const context = canvas.getContext('gpupresent');
    const swapChain = context.configureSwapChain({
        device,
        format: "bgra8unorm"
    });

    // -------------------------------------------- DOTS
    const dotsVSCode = `
        layout(location = 0) in vec2 position;
        void main() {
            gl_Position = vec4(position * 2.0 - vec2(1.0), 0.0, 1.0);
        }
    `;

    const dotsFSCode = `
        layout(location = 0) out vec4 fragColor;
        void main() {
            fragColor = vec4(1.0);
        }
    `;

    const dotsPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [] }),
        vertexStage: {
            module: compileShaderModule(device, "v", dotsVSCode),
            entryPoint: "main"
        },
        fragmentStage: {
            module: compileShaderModule(device, "f", dotsFSCode),
            entryPoint: "main"
        },
        primitiveTopology: "point-list",

        vertexInput: {
            indexFormat: "uint32",
            vertexBuffers: [{
                stride: 4 * PARTICLE_SIZE,
                attributes: [{
                    shaderLocation: 0,
                    offset: 0,
                    format: "float2"
                }],
            }],
        },

        rasterizationState: {
            frontFace: 'ccw',
        },

        colorStates: [{
            format: "bgra8unorm",
            alphaBlend: {},
            colorBlend: {},
        }],
    });

    // -------------------------------------------- METABALLS
    const metaballVSCode = `
        const vec2 pos[4] = vec2[4](
            vec2( 1.0f, -1.0f),
            vec2( 1.0f,  1.0f),
            vec2(-1.0f, -1.0f),
            vec2(-1.0f,  1.0f)
        );

        void main() {
            gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
        }
    `;

    const metaballFSCode = SHADER_HEADER + `
        layout(std430, set = 0, binding = 1) buffer ParticlesIn {
            Particle particles[];
        };

        layout(std430, set = 0, binding = 2) buffer Prefixes {
            uint gridPrefixSum[];
        };

        layout(std430, set = 0, binding = 3) buffer CountsOut {
            uint gridCounts[];
        };

        layout(location = 0) out vec4 fragColor;
        void main() {
            float squareSum = 0.0;
            vec2 pos = gl_FragCoord.xy / constants.screenSize;
            ivec2 gridPos = ivec2(posToGridPos(pos));

            ivec2 start = max(ivec2(0), gridPos - ivec2(4));
            ivec2 end = min(ivec2(constants.gridSize), gridPos + ivec2(5));
            for (uint x = start.x; x < end.x; x++) {
                for (uint y = start.y; y < end.y; y++) {
                    uint cellIndex = x + constants.gridSize * y;
                    uint offset = gridPrefixSum[cellIndex];
                    uint particleCount = gridCounts[cellIndex];
                    for (uint i = 0; i < particleCount; i++) {
                        vec2 particlePos = particles[offset + i].pos;
                        vec2 diff = particlePos - pos;
                        squareSum += 1.0 / max(constants.epsilon, dot(diff, diff));
                        if (squareSum > constants.metaballVolumeThreshold) {
                            fragColor = vec4(0.15, 0.3, 0.6, 1.0);
                            return;
                        }
                    }
                }
            }

            if (squareSum > constants.metaballSurfaceThreshold) {
                fragColor = vec4(0.3, 0.5, 0.8, 1.0);
                return;
            }
            discard;
        }
    `;

    const metaballBGL = device.createBindGroupLayout({
        bindings: [
            { binding: 0, visibility: GPUShaderStageBit.FRAGMENT, type: "uniform-buffer" },
            { binding: 1, visibility: GPUShaderStageBit.FRAGMENT, type: "storage-buffer" },
            { binding: 2, visibility: GPUShaderStageBit.FRAGMENT, type: "storage-buffer" },
            { binding: 3, visibility: GPUShaderStageBit.FRAGMENT, type: "storage-buffer" },
        ]
    });

    const metaballPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [metaballBGL] }),
        vertexStage: {
            module: compileShaderModule(device, "v", metaballVSCode),
            entryPoint: "main"
        },
        fragmentStage: {
            module: compileShaderModule(device, "f", metaballFSCode),
            entryPoint: "main"
        },
        primitiveTopology: "triangle-strip",

        vertexInput: {
            indexFormat: "uint32",
            vertexBuffers: [],
        },

        rasterizationState: {
            frontFace: 'ccw',
        },

        colorStates: [{
            format: "bgra8unorm",
            alphaBlend: {},
            colorBlend: {},
        }],
    });

    // -------------------------------------------- ADVECTION
    const advectCSCode = SHADER_HEADER + `
        layout(std430, set = 0, binding = 1) buffer ParticlesIn {
            Particle particlesIn[];
        };

        layout(std430, set = 0, binding = 2) buffer ParticlesOut {
            Particle particlesOut[];
        };

        void main() {
            uint index = gl_GlobalInvocationID.x;

            Particle particle = particlesIn[index];

            vec2 gravityForce = vec2(0, -constants.g) * constants.mass;
            vec2 sumForces = gravityForce; // particle.force
            vec2 acceleration = gravityForce / constants.mass + particle.accel;
            particle.vel += acceleration * constants.timestep;
            particle.pos += particle.vel * constants.timestep;

            // Elastic bouncing over the boundaries
            vec2 newPos = clamp(particle.pos, constants.epsilon, 1.0 - constants.epsilon);
            if (newPos.x != particle.pos.x) {
                particle.vel.x *= -0.5;
            }
            if (newPos.y != particle.pos.y) {
                particle.vel.y *= -0.5;
            }

            particlesOut[index] = particle;
        }
    `;
    const advectionBGL = device.createBindGroupLayout({
        bindings: [
            { binding: 0, visibility: GPUShaderStageBit.COMPUTE, type: "uniform-buffer" },
            { binding: 1, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 2, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
        ]
    });
    const advectionPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [advectionBGL] }),
        computeStage: {
            module: compileShaderModule(device, "c", advectCSCode),
            entryPoint: "main",
        },
    });

    // -------------------------------------------- ZERO BUFFER
    const zeroBufferCSCode = `
        layout(std430, set = 0, binding = 0) buffer ToZero {
             uint data[];
        };
        void main() {
            data[gl_GlobalInvocationID.x] = 0;
        }
    `;
    const zeroBufferBGL = device.createBindGroupLayout({
        bindings: [
            { binding: 0, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
        ]
    });
    const zeroBufferPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [zeroBufferBGL] }),
        computeStage: {
            module: compileShaderModule(device, "c", zeroBufferCSCode),
            entryPoint: "main",
        },
    });

    // -------------------------------------------- PREFIX SUM
    const PREFIX_SHARED_HEADER = `
        layout(std140, set = 0, binding = 0) uniform Uniforms {
            uint dataLength;
            uint coarseStride;
            uint smallStride;
        };

        layout(std430, set = 0, binding = 1) buffer Data {
            uint data[];
        };
    `;
    const prefixCoarseSumCSCode = PREFIX_SHARED_HEADER + `
        void main() {
            uint index = gl_GlobalInvocationID.x;

            uint rangeStart = index * coarseStride;
            uint rangeEnd = rangeStart + coarseStride;

            uint sum = 0;
            for (uint i = rangeStart; i < rangeEnd; i += smallStride) {
                sum += data[i + smallStride - 1];
            }

            data[rangeEnd - 1] = sum;
        }
    `;
    const prefixCoarseSumBGL = device.createBindGroupLayout({
        bindings: [
            { binding: 0, visibility: GPUShaderStageBit.COMPUTE, type: "uniform-buffer" },
            { binding: 1, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
        ]
    });
    const prefixCoarseSumPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [prefixCoarseSumBGL] }),
        computeStage: {
            module: compileShaderModule(device, "c", prefixCoarseSumCSCode),
            entryPoint: "main",
        },
    });

    const prefixExpandSumCSCode = PREFIX_SHARED_HEADER + `
        void main() {
            uint index = gl_GlobalInvocationID.x;

            uint rangeStart = index * coarseStride;
            uint rangeEnd = min(dataLength, rangeStart + coarseStride - smallStride);

            uint prefixSum;
            if (rangeStart == 0) {
                prefixSum = 0;
            } else {
                prefixSum = data[rangeStart - 1];
            }

            for (uint i = rangeStart; i < rangeEnd; i += smallStride) {
                prefixSum += data[i + smallStride - 1];
                data[i + smallStride - 1] = prefixSum;
            }
        }
    `;
    const prefixExpandSumBGL = device.createBindGroupLayout({
        bindings: [
            { binding: 0, visibility: GPUShaderStageBit.COMPUTE, type: "uniform-buffer" },
            { binding: 1, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
        ]
    });
    const prefixExpandSumPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [prefixExpandSumBGL] }),
        computeStage: {
            module: compileShaderModule(device, "c", prefixExpandSumCSCode),
            entryPoint: "main",
        },
    });

    function inPlacePrefixSum(device, encoder, buffer, size) {
        function prefixSumHelper(smallStride) {
            const REDUCTION_FACTOR = 8;
            const coarseStride = smallStride * REDUCTION_FACTOR;

            const uniforms = device.createBuffer({
                size: 12,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.TRANSFER_DST
            });
            uniforms.setSubData(0, new Uint32Array([size, coarseStride, smallStride]));

            const bindGroup = device.createBindGroup({
                layout: prefixCoarseSumBGL,
                bindings: [
                    {binding: 0, resource: {buffer: uniforms, offset: 0, size: 12}},
                    {binding: 1, resource: {buffer: buffer, offset: 0, size: size * 4}},
                ],
            });

            if (coarseStride < size) {
                // The number of element at a coarseStride stride except the first one.
                const dispatchSize = Math.floor((size - 1) / coarseStride);

                const pass = encoder.beginComputePass();
                pass.setPipeline(prefixCoarseSumPipeline);
                pass.setBindGroup(0, bindGroup);
                pass.dispatch(dispatchSize);
                pass.endPass();

                prefixSumHelper(coarseStride);
            }

            {
                const dispatchSize = Math.ceil(size / coarseStride);

                const pass = encoder.beginComputePass();
                pass.setPipeline(prefixExpandSumPipeline);
                pass.setBindGroup(0, bindGroup);
                pass.dispatch(dispatchSize + 1);
                pass.endPass();
            }
        }
        prefixSumHelper(1);
    }

    // await testPrefixSum(device, inPlacePrefixSum, N_GRID_CELLS);

    // -------------------------------------------- SINGLE DISPATCH PREFIX SUM (SLOW!!!!)
    const prefixSumCSCode = `
        layout(std430, set = 0, binding = 0) buffer DataIn {
            uint dataIn[];
        };

        layout(std430, set = 0, binding = 1) buffer DataOut {
            uint dataOut[];
        };

        const uint kFactor = 256;
        layout(local_size_x = kFactor) in;
        shared uint coarsePrefixes[kFactor];

        void main() {
            uint dataLength = ${N_GRID_CELLS}; // SPIRV-Cross doesn't know how to do dataIn.length();
            uint groupSize = (dataLength + kFactor - 1) / kFactor;
            uint index = gl_GlobalInvocationID.x;

            if (index != 0) {
                uint start = (index - 1) * groupSize;
                uint end = index * groupSize;

                uint sum = 0;
                for (uint i = start; i < end; i++) {
                    sum += dataIn[i];
                }
                coarsePrefixes[index] = sum;
            }
            barrier();

            if (index == 0) {
                coarsePrefixes[0] = 0;

                uint sum = 0;
                for (uint i = 1; i < kFactor; i++) {
                    sum += coarsePrefixes[i];
                    coarsePrefixes[i] = sum;
                }
            }
            barrier();

            uint start = index * groupSize;
            uint end = min((index + 1) * groupSize, dataLength);

            uint sum = coarsePrefixes[index];
            for (uint i = start; i < end; i++) {
                dataOut[i] = sum;
                sum += dataIn[i];
            }
        }
    `;
    const prefixSumBGL = device.createBindGroupLayout({
        bindings: [
            { binding: 0, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 1, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
        ]
    });
    const prefixSumPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [prefixSumBGL] }),
        computeStage: {
            module: compileShaderModule(device, "c", prefixSumCSCode),
            entryPoint: "main",
        },
    });


    // -------------------------------------------- COUNT PARTICLES
    const countParticlesCSCode = SHADER_HEADER + `
        layout(std430, set = 0, binding = 1) buffer ParticlesIn {
            Particle particles[];
        };

        layout(std430, set = 0, binding = 2) buffer CountsOut {
            uint counts[];
        };

        void main() {
            uint index = gl_GlobalInvocationID.x;
            vec2 pos = particles[index].pos;

            uint gridOffset = gridPosToOffset(posToGridPos(pos));
            atomicAdd(counts[gridOffset], 1);
        }
    `;
    const countParticlesBGL = device.createBindGroupLayout({
        bindings: [
            { binding: 0, visibility: GPUShaderStageBit.COMPUTE, type: "uniform-buffer" },
            { binding: 1, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 2, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
        ]
    });
    const countParticlesPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [countParticlesBGL] }),
        computeStage: {
            module: compileShaderModule(device, "c", countParticlesCSCode),
            entryPoint: "main",
        },
    });

    // -------------------------------------------- REORDER PARTICLES
    const reorderParticlesCSCode = SHADER_HEADER + `
        layout(std430, set = 0, binding = 1) buffer ParticlesIn {
            Particle particlesIn[];
        };

        layout(std430, set = 0, binding = 2) buffer ParticlesOut {
            Particle particlesOut[];
        };

        layout(std430, set = 0, binding = 3) buffer Prefixes {
            uint prefixSum[];
        };

        layout(std430, set = 0, binding = 4) buffer CountsOut {
            uint counts[];
        };

        void main() {
            uint index = gl_GlobalInvocationID.x;
            vec2 pos = particlesIn[index].pos;

            uint gridOffset = gridPosToOffset(posToGridPos(pos));
            uint previousCount = atomicAdd(counts[gridOffset], 1);
            uint newIndex = previousCount + prefixSum[gridOffset];
            particlesOut[newIndex] = particlesIn[index];
        }
    `;
    const reorderParticlesBGL = device.createBindGroupLayout({
        bindings: [
            { binding: 0, visibility: GPUShaderStageBit.COMPUTE, type: "uniform-buffer" },
            { binding: 1, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 2, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 3, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 4, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
        ]
    });
    const reorderParticlesPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [reorderParticlesBGL] }),
        computeStage: {
            module: compileShaderModule(device, "c", reorderParticlesCSCode),
            entryPoint: "main",
        },
    });

    // -------------------------------------------- COMPUTE WEIGHT (AND PRESSURE).
    const computeWeightCSCode = SHADER_HEADER + `
        layout(std430, set = 0, binding = 1) buffer ParticlesIn {
            Particle particlesIn[];
        };
        layout(std430, set = 0, binding = 2) buffer ParticlesOut {
            Particle particlesOut[];
        };
        layout(std430, set = 0, binding = 3) buffer Prefixes {
            uint gridPrefixSum[];
        };
        layout(std430, set = 0, binding = 4) buffer CountsOut {
            uint gridCounts[];
        };
        float W(float dist, float h) {
            float x = dist / h;
            if (x < 0.5f) {
                return 1 + 6 * x * x * (x - 1);
            } else if(x < 1.0f) {
                const float y = 1 - x;
                return 2 * y * y * y;
            } else {
                return 0;
            }
        }
        void main() {
            uint index = gl_GlobalInvocationID.x;
            Particle particle = particlesIn[index];

            uvec2 start = posToGridPos(particle.pos - vec2(constants.particleRadius));
            uvec2 end = posToGridPos(particle.pos + vec2(constants.particleRadius));

            float rho = 0.0;
            for (uint x = start.x; x <= end.x; x++) {
                for (uint y = start.y; y <= end.y; y++) {
                    uint gridCellIndex = gridPosToOffset(uvec2(x, y));
                    uint offset = gridPrefixSum[gridCellIndex];
                    uint particleCount = gridCounts[gridCellIndex];
                    for (uint i = 0; i < particleCount; i++) {
                        float dist = distance(particlesIn[offset + i].pos, particle.pos);
                        rho += W(dist, constants.particleRadius);
                    }
                }
            }

            particle.rho = rho;
            particle.pressure = constants.celerity * constants.celerity * (rho - constants.rho0);
            particlesOut[index] = particle;
        }
    `;
    const computeWeightBGL = device.createBindGroupLayout({
        bindings: [
            { binding: 0, visibility: GPUShaderStageBit.COMPUTE, type: "uniform-buffer" },
            { binding: 1, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 2, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 3, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 4, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
        ]
    });
    const computeWeightPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [computeWeightBGL] }),
        computeStage: {
            module: compileShaderModule(device, "c", computeWeightCSCode),
            entryPoint: "main",
        },
    });

    // -------------------------------------------- COMPUTE ACCELERATION
    const computeAccelCSCode = SHADER_HEADER + `
        layout(std430, set = 0, binding = 1) buffer ParticlesIn {
            Particle particlesIn[];
        };
        layout(std430, set = 0, binding = 2) buffer ParticlesOut {
            Particle particlesOut[];
        };
        layout(std430, set = 0, binding = 3) buffer Prefixes {
            uint gridPrefixSum[];
        };
        layout(std430, set = 0, binding = 4) buffer CountsOut {
            uint gridCounts[];
        };

        float dW(float dist, float h) {
            const float x = dist / h;
            if (x < 0.5f) {
                return (18 * x - 12) * x / h;
            } else if(x < 1.0f) {
                const float y = 1 - x;
                return - 4 / h * y * y;
            } else {
                return 0;
            }
        }

        float laplacianW (float dist, float h) {
            const float x = dist / h;
            float result;
            if (x < 0.5f) {
                result = (36 * x - 12) / h / h;
            } else if (x < 1.0f) {
                const float y = 1 - x;
                result = - 4 / h / h * y;
            } else {
                return 0;
            }
            return result + dW(dist, h) / max(0.000001, x);
        }

        void main() {
            uint index = gl_GlobalInvocationID.x;
            Particle particle = particlesIn[index];

            uvec2 start = posToGridPos(particle.pos - vec2(constants.particleRadius));
            uvec2 end = posToGridPos(particle.pos + vec2(constants.particleRadius));

            // http://matthias-mueller-fischer.ch/publications/sca03.pdf

            vec2 accel = vec2(0.0);
            for (uint x = start.x; x <= end.x; x++) {
                for (uint y = start.y; y <= end.y; y++) {
                    uint gridCellIndex = gridPosToOffset(uvec2(x, y));
                    uint offset = gridPrefixSum[gridCellIndex];
                    uint particleCount = gridCounts[gridCellIndex];
                    for (uint i = 0; i < particleCount; i++) {
                        if (offset + i == index) {
                            continue;
                        }
                        Particle other = particlesIn[offset + i];
                        float dist = distance(other.pos, particle.pos);
                        vec2 gradientW = (other.pos - particle.pos) * dW(dist, constants.particleRadius);
                        accel += gradientW * (particle.pressure + other.pressure) / (2.0 * other.rho);
                    }
                }
            }

            particle.accel = accel;
            particlesOut[index] = particle;
        }
    `;
    const computeAccelBGL = device.createBindGroupLayout({
        bindings: [
            { binding: 0, visibility: GPUShaderStageBit.COMPUTE, type: "uniform-buffer" },
            { binding: 1, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 2, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 3, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
            { binding: 4, visibility: GPUShaderStageBit.COMPUTE, type: "storage-buffer" },
        ]
    });
    const computeAccelPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [computeAccelBGL] }),
        computeStage: {
            module: compileShaderModule(device, "c", computeAccelCSCode),
            entryPoint: "main",
        },
    });


    // -------------------------------------------- BUFFER SETUP
    const constantsData = new Float32Array([
        0, 0, // screenSize
        0, // gridSize
        0.002, // timestep
        4.0, // g
        0.001, // mass
        0.0000001, // epsilon
        100000.0, // metaballVolumeThreshold
        25000.0, // metaballSurfaceThreshold
        RADIUS, // particleRadius
        3.0, // Speed of sound used to derive k in p = k(rho - rho0)
        2.0, // rho0
        1.0, // mu
    ]);
    const constantsDataUint = new Uint32Array(constantsData.buffer);
    constantsDataUint[0] = 800;
    constantsDataUint[1] = 800;
    constantsDataUint[2] = GRID_SIZE;

    const constantsBuffer = device.createBuffer({
        size: constantsData.length * 4,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.TRANSFER_DST
    });
    constantsBuffer.setSubData(0, constantsData);

    const particleData = new Float32Array(N_PARTICLES * PARTICLE_SIZE);
    for (let i = 0; i < N_PARTICLES; i++) {
        particleData[i * PARTICLE_SIZE + 0] = Math.random() / 2;
        particleData[i * PARTICLE_SIZE + 1] = Math.random();
        particleData[i * PARTICLE_SIZE + 2] = (Math.random() - 0.5) / 50;
        particleData[i * PARTICLE_SIZE + 3] = (Math.random() - 0.5) / 50;
    }

    const particleBuffers = []
    for (let i = 0; i < 2; i ++) {
        particleBuffers.push(device.createBuffer({
            size: N_PARTICLES * PARTICLE_SIZE * 4,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.TRANSFER_DST
        }));
        particleBuffers[i].setSubData(0, particleData);
    }
    function swapParticles() {
        particleBuffers0 = particleBuffers[0];
        particleBuffers[0] = particleBuffers[1];
        particleBuffers[1] = particleBuffers0;
    }

    const gridCountBuffer = device.createBuffer({
        size: N_GRID_CELLS * 4,
        usage: GPUBufferUsage.STORAGE,
    });
    const gridPrefixSumBuffer = device.createBuffer({
        size: N_GRID_CELLS * 4,
        usage: GPUBufferUsage.STORAGE,
    });

    // -------------------------------------------- FRAME
    function frame() {
        const encoder = device.createCommandEncoder({});
        // Compute number of particles in each grid cell.
        {
            const zeroBindGroup = device.createBindGroup({
                layout: zeroBufferBGL,
                bindings: [
                    {binding: 0, resource: {buffer: gridCountBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                ],
            });

            const zeroPass = encoder.beginComputePass();
            zeroPass.setPipeline(zeroBufferPipeline);
            zeroPass.setBindGroup(0, zeroBindGroup);
            zeroPass.dispatch(N_GRID_CELLS);
            zeroPass.endPass();

            const countBindGroup = device.createBindGroup({
                layout: countParticlesBGL,
                bindings: [
                    {binding: 0, resource: {buffer: constantsBuffer, offset: 0, size: constantsData.length * 4}},
                    {binding: 1, resource: {buffer: particleBuffers[0], offset: 0, size: N_PARTICLES * PARTICLE_SIZE * 4}},
                    {binding: 2, resource: {buffer: gridCountBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                ],
            });

            const countPass = encoder.beginComputePass();
            countPass.setPipeline(countParticlesPipeline);
            countPass.setBindGroup(0, countBindGroup);
            countPass.dispatch(N_PARTICLES);
            countPass.endPass();
        }
        // Compute prefix sum of the grid.
        {
            const bindGroup = device.createBindGroup({
                layout: prefixSumBGL,
                bindings: [
                    {binding: 0, resource: {buffer: gridCountBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                    {binding: 1, resource: {buffer: gridPrefixSumBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                ],
            });

            const pass = encoder.beginComputePass();
            pass.setPipeline(prefixSumPipeline);
            pass.setBindGroup(0, bindGroup);
            pass.dispatch(256);
            pass.endPass();
        }
        // Reorder particles based on prefix count.
        {
            const zeroBindGroup = device.createBindGroup({
                layout: zeroBufferBGL,
                bindings: [
                    {binding: 0, resource: {buffer: gridCountBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                ],
            });

            const zeroPass = encoder.beginComputePass();
            zeroPass.setPipeline(zeroBufferPipeline);
            zeroPass.setBindGroup(0, zeroBindGroup);
            zeroPass.dispatch(N_GRID_CELLS);
            zeroPass.endPass();

            const reorderBindGroup = device.createBindGroup({
                layout: reorderParticlesBGL,
                bindings: [
                    {binding: 0, resource: {buffer: constantsBuffer, offset: 0, size: constantsData.length * 4}},
                    {binding: 1, resource: {buffer: particleBuffers[0], offset: 0, size: N_PARTICLES * PARTICLE_SIZE * 4}},
                    {binding: 2, resource: {buffer: particleBuffers[1], offset: 0, size: N_PARTICLES * PARTICLE_SIZE * 4}},
                    {binding: 3, resource: {buffer: gridPrefixSumBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                    {binding: 4, resource: {buffer: gridCountBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                ],
            });

            const reorderPass = encoder.beginComputePass();
            reorderPass.setPipeline(reorderParticlesPipeline);
            reorderPass.setBindGroup(0, reorderBindGroup);
            reorderPass.dispatch(N_PARTICLES);
            reorderPass.endPass();

            swapParticles();
        }
        // Render everything.
        {
            const metaballBindGroup = device.createBindGroup({
                layout: metaballBGL,
                bindings: [
                    {binding: 0, resource: {buffer: constantsBuffer, offset: 0, size: constantsData.length * 4}},
                    {binding: 1, resource: {buffer: particleBuffers[0], offset: 0, size: N_PARTICLES * PARTICLE_SIZE * 4}},
                    {binding: 2, resource: {buffer: gridPrefixSumBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                    {binding: 3, resource: {buffer: gridCountBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                ],
            });

            const metaPass = encoder.beginRenderPass({
                colorAttachments: [{
                    attachment: swapChain.getCurrentTexture().createDefaultView(),
                    loadOp: "clear",
                    storeOp: "store",
                    clearColor: {r:0.0, g:0.0, b:0.0, a:1.0},
                }]
            });
            metaPass.setPipeline(metaballPipeline);
            metaPass.setBindGroup(0, metaballBindGroup);
            metaPass.draw(4, 1, 0, 0);
            metaPass.endPass();

            const dotsPass = encoder.beginRenderPass({
                colorAttachments: [{
                    attachment: swapChain.getCurrentTexture().createDefaultView(),
                    loadOp: "load",
                    storeOp: "store",
                    clearColor: {r:0.0, g:0.0, b:0.0, a:1.0},
                }]
            });
            dotsPass.setVertexBuffers(0, [particleBuffers[0]], [0]);
            dotsPass.setPipeline(dotsPipeline);
            dotsPass.draw(N_PARTICLES, 1, 0, 0);
            dotsPass.endPass();
        }
        // Compute rho and pressure
        {
            const computeWeightBindGroup = device.createBindGroup({
                layout: computeWeightBGL,
                bindings: [
                    {binding: 0, resource: {buffer: constantsBuffer, offset: 0, size: constantsData.length * 4}},
                    {binding: 1, resource: {buffer: particleBuffers[0], offset: 0, size: N_PARTICLES * PARTICLE_SIZE * 4}},
                    {binding: 2, resource: {buffer: particleBuffers[1], offset: 0, size: N_PARTICLES * PARTICLE_SIZE * 4}},
                    {binding: 3, resource: {buffer: gridPrefixSumBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                    {binding: 4, resource: {buffer: gridCountBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                ],
            });
            const pass = encoder.beginComputePass();
            pass.setPipeline(computeWeightPipeline);
            pass.setBindGroup(0, computeWeightBindGroup);
            pass.dispatch(N_PARTICLES);
            pass.endPass();
            swapParticles();
        }
        // Compute the acceleration
        {
            const computeAccelBindGroup = device.createBindGroup({
                layout: computeAccelBGL,
                bindings: [
                    {binding: 0, resource: {buffer: constantsBuffer, offset: 0, size: constantsData.length * 4}},
                    {binding: 1, resource: {buffer: particleBuffers[0], offset: 0, size: N_PARTICLES * PARTICLE_SIZE * 4}},
                    {binding: 2, resource: {buffer: particleBuffers[1], offset: 0, size: N_PARTICLES * PARTICLE_SIZE * 4}},
                    {binding: 3, resource: {buffer: gridPrefixSumBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                    {binding: 4, resource: {buffer: gridCountBuffer, offset: 0, size: N_GRID_CELLS * 4}},
                ],
            });
            const pass = encoder.beginComputePass();
            pass.setPipeline(computeAccelPipeline);
            pass.setBindGroup(0, computeAccelBindGroup);
            pass.dispatch(N_PARTICLES);
            pass.endPass();
            swapParticles();
        }
        // Advect particles based on the force computed
        {
            const bindGroup = device.createBindGroup({
                layout: advectionBGL,
                bindings: [
                    {binding: 0, resource: {buffer: constantsBuffer, offset: 0, size: constantsData.length * 4}},
                    {binding: 1, resource: {buffer: particleBuffers[0], offset: 0, size: N_PARTICLES * PARTICLE_SIZE * 4}},
                    {binding: 2, resource: {buffer: particleBuffers[1], offset: 0, size: N_PARTICLES * PARTICLE_SIZE * 4}},
                ],
            });

            const pass = encoder.beginComputePass();
            pass.setPipeline(advectionPipeline);
            pass.setBindGroup(0, bindGroup);
            pass.dispatch(N_PARTICLES);
            pass.endPass();

            swapParticles();
        }

        device.getQueue().submit([encoder.finish()]);
        requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
}

init();

</script>
</body>
</html>
